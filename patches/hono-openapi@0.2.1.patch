diff --git a/index.esm.js b/index.esm.js
index 4a25e16d3cdc3d52939539729809e97e53099fbe..b95d08e9fec97e148624f6782c1f3ec52e985703 100644
--- a/index.esm.js
+++ b/index.esm.js
@@ -1,10 +1 @@
-import { HTTPException } from 'hono/http-exception';
-import { u as uniqueSymbol } from './utils.esm.js';
-
-function describeRoute(specs){const middleware=async(c,next)=>{await next();if(specs.validateResponse&&specs.responses){const status=c.res.status;const contentType=c.res.headers.get("content-type");if(status&&contentType){const response=specs.responses[status];if(response&&"content"in response&&response.content){const content=response.content[contentType];if(content?.schema&&"validator"in content.schema){try{await content.schema.validator(c.res.body);}catch(error){throw new HTTPException(400,{message:"Response validation failed!"})}}}}}};return Object.assign(middleware,{[uniqueSymbol]:{resolver:async config=>{const docs={...specs};let components={};if(docs.responses){for(const key of Object.keys(docs.responses)){const response=docs.responses[key];if(response&&!("content"in response))continue;for(const contentKey of Object.keys(response.content??{})){const raw=response.content?.[contentKey];if(!raw)continue;if(raw.schema&&"builder"in raw.schema){const result=await raw.schema.builder(config);raw.schema=result.schema;if(result.components){components={...components,...result.components};}}}}}return {docs,components}}}})}
-
-const ALLOWED_METHODS=["GET","PUT","POST","DELETE","OPTIONS","HEAD","PATCH","TRACE"];const toOpenAPIPath=path=>path.split("/").map(x=>{let tmp=x;if(tmp.startsWith(":")){tmp=tmp.slice(1,tmp.length);if(tmp.endsWith("?"))tmp=tmp.slice(0,-1);tmp=`{${tmp}}`;}return tmp}).join("/");const capitalize=word=>word.charAt(0).toUpperCase()+word.slice(1);const generateOperationId=(method,paths)=>{let operationId=method;if(paths==="/")return `${operationId}Index`;for(const path of paths.split("/")){if(path.charCodeAt(0)===123){operationId+=`By${capitalize(path.slice(1,-1))}`;}else {operationId+=capitalize(path);}}return operationId};function registerSchemaPath({path,method:_method,data,schema}){path=toOpenAPIPath(path);const method=_method.toLowerCase();schema[path]={...schema[path]?schema[path]:{},[method]:{responses:{},...schema[path]?.[method]??{},operationId:generateOperationId(method,path),...data}};}function filterPaths(paths,{excludeStaticFile=true,exclude=[]}){const newPaths={};for(const[key,value]of Object.entries(paths)){if(!exclude.some(x=>{if(typeof x==="string")return key===x;return x.test(key)})&&!key.includes("*")&&(excludeStaticFile?!key.includes("."):true)){for(const method of Object.keys(value)){const schema=value[method];if(key.includes("{")){if(!schema.parameters)schema.parameters=[];schema.parameters=[...key.split("/").filter(x=>x.startsWith("{")&&!schema.parameters.find(params=>params.in==="path"&&params.name===x.slice(1,x.length-1))).map(x=>({schema:{type:"string"},in:"path",name:x.slice(1,x.length-1),required:true})),...schema.parameters];}if(!schema.responses)schema.responses={200:{}};}newPaths[key]=value;}}return newPaths}
-
-function openAPISpecs(hono,{documentation={},excludeStaticFile=true,exclude=[],excludeMethods=["OPTIONS"],excludeTags=[]}={documentation:{},excludeStaticFile:true,exclude:[],excludeMethods:["OPTIONS"],excludeTags:[]}){const config={version:"3.1.0",components:{}};const schema={};let specs=null;return async c=>{if(specs)return c.json(specs);for(const route of hono.routes){if(!(uniqueSymbol in route.handler))continue;if(excludeMethods.includes(route.method))continue;if(ALLOWED_METHODS.includes(route.method)===false&&route.method!=="ALL")continue;const{resolver,metadata={}}=route.handler[uniqueSymbol];const{docs,components}=await resolver({...config,...metadata});config.components={...config.components,...components??{}};if(route.method==="ALL"){for(const method of ALLOWED_METHODS){registerSchemaPath({path:route.path,data:docs,method,schema});}}else {registerSchemaPath({method:route.method,path:route.path,data:docs,schema});}}for(const path in schema){for(const method in schema[path]){const valueOrFunc=schema[path][method]?.hide;if(valueOrFunc&&(typeof valueOrFunc==="boolean"?valueOrFunc:valueOrFunc(c))){delete schema[path][method];}}}specs={openapi:config.version,...{...documentation,tags:documentation.tags?.filter(tag=>!excludeTags?.includes(tag?.name)),info:{title:"Hono Documentation",description:"Development documentation",version:"0.0.0",...documentation.info},paths:{...filterPaths(schema,{excludeStaticFile,exclude:Array.isArray(exclude)?exclude:[exclude]}),...documentation.paths},components:{...documentation.components,schemas:{...config.components,...documentation.components?.schemas}}}};return c.json(specs)}}
-
-export { describeRoute, openAPISpecs };
+import{HTTPException as e}from"hono/http-exception";import{u as t}from"./utils.esm.js";function n(n){return Object.assign((async(t,s)=>{if(await s(),n.validateResponse&&n.responses){const s=t.res.status,o=t.res.headers.get("content-type");if(s&&o){const c=n.responses[s];if(c&&"content"in c&&c.content){const n=c.content[o];if(n?.schema&&"validator"in n.schema)try{await n.schema.validator(t.res.body)}catch(t){throw new e(400,{message:"Response validation failed!"})}}}}}),{[t]:{resolver:async e=>{const t={...n};let s={};if(t.responses)for(const n of Object.keys(t.responses)){const o=t.responses[n];if(!o||"content"in o)for(const t of Object.keys(o.content??{})){const n=o.content?.[t];if(n&&(n.schema&&"builder"in n.schema)){const t=await n.schema.builder(e);n.schema=t.schema,t.components&&(s={...s,...t.components})}}}return{docs:t,components:s}}}})}const s=["GET","PUT","POST","DELETE","OPTIONS","HEAD","PATCH","TRACE"],o=e=>e.charAt(0).toUpperCase()+e.slice(1),c=(e,t)=>{let n=e;if("/"===t)return`${n}Index`;for(const e of t.split("/"))123===e.charCodeAt(0)?n+=`By${o(e.slice(1,-1))}`:n+=o(e);return n};function a({path:e,method:t,data:n,schema:s}){e=(e=>e.split("/").map((e=>{let t=e;return t.startsWith(":")&&(t=t.slice(1,t.length),t.endsWith("?")&&(t=t.slice(0,-1)),t=`{${t}}`),t})).join("/"))(e);const o=t.toLowerCase();s[e]={...s[e]?s[e]:{},[o]:{responses:{},...s[e]?.[o]??{},operationId:c(o,e),...n}}}function i(e,{excludeStaticFile:t=!0,exclude:n=[]}){const s={};for(const[o,c]of Object.entries(e))if(!(n.some((e=>"string"==typeof e?o===e:e.test(o)))||o.includes("*")||t&&o.includes("."))){for(const e of Object.keys(c)){const t=c[e];if(o.includes("{")){t.parameters||(t.parameters=[]);const e=o.split("/").filter((e=>e.startsWith("{")&&!t.parameters.find((t=>"path"===t.in&&t.name===e.slice(1,e.length-1)))));for(const n of e){const e=n.slice(1,n.length-1),s=t.parameters.findIndex((t=>"param"===t.in&&t.name===e));-1!==s?t.parameters[s].in="path":t.parameters.push(n)}}t.responses||(t.responses={200:{}})}s[o]=c}return s}function r(e,{documentation:n={},excludeStaticFile:o=!0,exclude:c=[],excludeMethods:r=["OPTIONS"],excludeTags:l=[]}={documentation:{},excludeStaticFile:!0,exclude:[],excludeMethods:["OPTIONS"],excludeTags:[]}){const d={version:"3.1.0",components:{}},p={};let m=null;return async h=>{if(m)return h.json(m);for(const n of e.routes){if(!(t in n.handler))continue;if(r.includes(n.method))continue;if(!1===s.includes(n.method)&&"ALL"!==n.method)continue;const{resolver:e,metadata:o={}}=n.handler[t],{docs:c,components:i}=await e({...d,...o});if(d.components={...d.components,...i??{}},"ALL"===n.method)for(const e of s)a({path:n.path,data:c,method:e,schema:p});else a({method:n.method,path:n.path,data:c,schema:p})}for(const e in p)for(const t in p[e]){const n=p[e][t]?.hide;n&&("boolean"==typeof n?n:n(h))&&delete p[e][t]}return m={openapi:d.version,...{...n,tags:n.tags?.filter((e=>!l?.includes(e?.name))),info:{title:"Hono Documentation",description:"Development documentation",version:"0.0.0",...n.info},paths:{...i(p,{excludeStaticFile:o,exclude:Array.isArray(c)?c:[c]}),...n.paths},components:{...n.components,schemas:{...d.components,...n.components?.schemas}}}},h.json(m)}}export{n as describeRoute,r as openAPISpecs};
